**SENG 438 - Software Testing, Reliability, and Quality**

**Lab. Report \#2 – Requirements-Based Test Generation**

| Group \#:      |  9                  |
| -------------- | ------------------- |
| Student Names: |  Christina Wyllie   |
|                |  Maitry Rohit       |
|                |  Sobia Khan         |
|                |  Jamie Stade        |

# 1 Introduction

Text…

# 2 Detailed description of unit test strategy

// including the input partitions you have designed

# 3 Test cases developed

Text…

// write down the name of the test methods and classes. Organize the based on
the source code method // they test. identify which tests cover which partitions
you have explained in the test strategy section //above

# 4 How the team work/effort was divided and managed

Text…

# 5 Difficulties encountered, challenges overcome, and lessons learned

As the team was writing tests, we became confused about how certain tests worked. The group had to determine whether errors occurred because of a bug in the program or an error in the way the test case was written. Sometimes JUnit would cause certain errors to occur with the test cases that were not reproducible. As we got more comfortable with writing tests we realized that there were bugs in the code and our tests were written correctly.

The team also struggled with learning mockery and how mocks and stubs can be incorporated in the tests written. After spending time in this lab the team learned more about mockery and grew comfortable with using it. 
Knowing how many tests to create per method was a difficulty faced. Certain tests that didn’t seem to have a purpose, but were written just as a precaution ended up providing valuable information that was not otherwise considered.


# 6 Comments/feedback on the lab itself

The instructions in the JUnit set up were clear and thorough, however some references to libraries in the explanation did not match what we were given. The JavaDoc does not clearly explain when exceptions are thrown. For example, an invalid parameter exception gets called when an incorrect data object is thrown, but a Junit program does not even compile when using invalid data objects. 
